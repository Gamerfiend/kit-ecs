import kit.map;

trait Component {
    function typeIdentifier(): CString;
    public function base(): Ptr[Void]{
        return &this;
    }
}

struct Entity {
    private var components: Map[CString, Box[Component]]; 
    public var uniqueID: Uint32;
    public var name: CString;
    private var allocator: Box[Allocator];
    
    private static var id: Uint32 = 0;

    public static function new(allocator: Box[Allocator], name: CString): Entity using implicit allocator {
        var components = Map.new(10);
        var uniqueID: Uint32 = Entity.id++;

        return struct Self {
            components,
            uniqueID,
            name,
            allocator
        };
    }

    public function addComponent(component: Box[Component]) {
        if !this.containsComponent(component)  {
            this.components.put(component.typeIdentifier(), component);
        }
        else {
            this.components.remove(component.typeIdentifier());
            this.components.put(component.typeIdentifier(), component);
        }
    }

    public function getComponent(typeIdentifier: CString): Option[Box[Component]] {
        if this.components.exists(typeIdentifier) {
            return this.components.get(typeIdentifier);
        }
        return None;
    }

    public function getComponents(): Array[CString] {
        return this.components.keys();
    }

    public function containsComponent(component: Box[Component]): Bool {
        return this.components.exists(component.typeIdentifier());
    }

    public function removeComponent(typeIdentifier: CString): Void {
        this.components.remove(typeIdentifier);
    }
}