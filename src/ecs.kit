import kit.map;
import utils.set;

enum EntityState{
    COMPONENT_ADDED;
    COMPONENT_REMOVED;

    public function toString(): CString{
        match this{
            COMPONENT_ADDED => return "added";
            COMPONENT_REMOVED => return "removed";
        }
    }
}

trait Component {
    function typeIdentifier(): CString;
    public function base(): Ptr[Void]{
        return &this;
    }
}

trait System {
    public function update(): Void;
}

struct Entity {
    private var components: Map[CString, Box[Component]]; 
    private var allocator: Box[Allocator];
    public var uniqueID: Uint32;
    public var name: CString;
    private var engine: Ptr[Engine];
    
    private static var id: Uint32 = 0;

    public static function new(allocator: Box[Allocator], name: CString): Entity using implicit allocator {
        var components = Map.new(10);
        var uniqueID: Uint32 = Entity.id++;

        return struct Self {
            components,
            allocator,
            uniqueID,
            name,
        };
    }

    public function addComponent(component: Box[Component]) {
        if !this.containsComponent(component.typeIdentifier())  {
            this.components.put(component.typeIdentifier(), component);
            this.notifiyChange(EntityState.COMPONENT_ADDED, component.typeIdentifier());
        }
        else {
            this.components.remove(component.typeIdentifier());
            this.components.put(component.typeIdentifier(), component);
        }
    }

    public function getComponent(typeIdentifier: CString): Option[Box[Component]] {
        if this.components.exists(typeIdentifier) {
            return this.components.get(typeIdentifier);
        }
        return None;
    }

    public function getComponents(): Array[CString] {
        return this.components.keys();
    }

    public function containsComponent(type: CString): Bool {
        return this.components.exists(type);
    }

    public function removeComponent(typeIdentifier: CString): Void {
        if(this.containsComponent(typeIdentifier)){
            this.components.remove(typeIdentifier);
            this.notifiyChange(EntityState.COMPONENT_REMOVED, typeIdentifier);
        }
    }

    private function notifiyChange(change: EntityState, typeIdentifier: CString){
        this.engine.entityHasChanged(change, typeIdentifier, this.uniqueID);
    }
}

struct Engine {
    private var entities: Map[Int, Ptr[Entity]];
    private var systems: Vector[Box[System]];
    private var entitesToComponent: Map[CString, Set[Int]];
    private var allocator: Box[Allocator];

    public static function new(allocator: Box[Allocator]): Engine using implicit allocator {
        var entities: Map[Int, Ptr[Entity]] = Map.new(10);
        var systems: Vector[Box[System]] = Vector.new(10);
        var entitesToComponent: Map[CString, Set[Int]] = Map.new(10);

        return struct Self {
            entities,
            systems,
            entitesToComponent,
            allocator
        };
    }

    public function addEntity(entity: Ptr[Entity]) {
        

        if(!this.entities.exists(entity.uniqueID)) {
            this.entities.put(entity.uniqueID, entity);
            entity.engine = &this;

            var list = entity.getComponents();

            for type in list{
                if(this.entitesToComponent.exists(type)) {
                    var entitySet: Set[Int] = this.entitesToComponent.get(type).unwrap();
                    entitySet.put(entity.uniqueID);
                }
                else {
                    var entitySet: Set[Int] = Set.new();
                    entitySet.put(entity.uniqueID);
                    this.entitesToComponent.put(type, entitySet);
                }
            }
        }
    }

    public function removeEntity(entity: Entity) {
        if(this.entities.exists(entity.uniqueID)) {
            this.entities.remove(entity.uniqueID);

            var list = entity.getComponents();

            for type in list{
                if(this.entitesToComponent.exists(type)) {
                    var entitySet: Set[Int] = this.entitesToComponent.get(type).unwrap();
                    entitySet.remove(entity.uniqueID);
                }
            }
        }
    }

    public function entityHasChanged(change: EntityState, typeIdentifier: CString, entityID: Uint32){
        printf("Entity: %i, has %s, Component: %s\n", entityID, change.toString(), typeIdentifier);
    }

    public function addSystem(system: Box[System]) {

    }

    public function removeSystem(system: Box[System]) {
        
    }

    public function entitiesForComponent(type: CString): Array[Ptr[Entity]] {

    }

    public function update() {

    }
}