import kit.vector;
import kit.map;

trait Component
{
    function typeIdentifier(): CString;
}

struct Entity
{
    //will be changed to a hashmap when it is avalible for use
    private var componentsList: Vector[Box[Component]]; 
    public var uniqueID: Uint32;
    public var name : CString;
    private var allocator: Box[Allocator];
    
    private static var id : Uint32 = 0;

    public static function new(allocator: Box[Allocator], name: CString) : Entity using implicit allocator
    {
        var componentsList: Vector[Box[Component]] = Vector.new(10);
        var uniqueID: Uint32 = Entity.id++;

        return struct Self
        {
            componentsList,
            uniqueID,
            name,
            allocator
        };
    }

    public function addComponent(component: Box[Component])
    {
        if(!(this.contains(component)))
        {
            this.componentsList.push(component);
        }
    }

    //this is Log(n), will need to be changed when map is ready for use
    private function contains(component : Box[Component]): Bool
    {
        for i in 0 ... this.componentsList.length
        {
            if(this.componentsList[i].typeIdentifier() == component.typeIdentifier())
            {
                return true;
            }
        }
        return false;
    }
}

function main()
{
    var entity1 : Entity = Entity.new("Apple");
    var entity2 : Entity = Entity.new("Orange");

    printf("%d", entity1.uniqueID);
    printf("%d", entity2.uniqueID);
}